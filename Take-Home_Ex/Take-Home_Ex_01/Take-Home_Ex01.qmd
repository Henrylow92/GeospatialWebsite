---
title: "Take Home Exercise 01"
author: "Henry Low"
date: "Sep 2 2024"
date-modified: "last-modified"
execute:
  evalu: true
  echo: true
  message: false
  freeze: true
format: html
editor: visual
---

# Background

Road traffic accidents cause 1.19 million deaths and 20 to 50 million injuries annually, with most fatalities occurring in low- and middle-income countries (World Health Organisation (WHO)). Road traffic injuries are the leading cause of death for individuals aged 5–29 and place a heavy economic burden on nations, costing up to 3% of GDP. Thailand has some of the deadliest roads globally, with about 20,000 fatalities annually. From 2014 to 2021, accidents rose, especially on national highways, with black spots frequently found on straight roads and intersections.

# Objectives

Focusing in the Bangkok Metropolitan Region (BMR), Spatial Point Patterns Analysis (SPPA) will be used to explore and identify factors influencing road traffic accidents. Such facts are mainly behavioral and environmental, with this exercise aiming to incorporate temporal factors as well. Specific objectives are as follows:\
- To visualize the spatio-temporal dynamics of road traffic accidents in BMR using appropriate statistical graphics and geovisualization methods.\
- To conduct detailed spatial analysis of road traffic accidents using appropriate Network Spatial Point Patterns Analysis methods.\
- To conduct detailed spatio-temporal analysis of road traffic accidents using appropriate Temporal Network Spatial Point Patterns Analysis methods.

# Study Area

The study area will be Bangkok Metropolitan Region, which is defined [here](https://en.wikipedia.org/wiki/Bangkok_Metropolitan_Region).

# Data Sources

*(saved under 'data' folder)*\
[Thailand Road Accident 2019-2022](https://www.kaggle.com/datasets/thaweewatboy/thailand-road-accident-2019-2022) from Kaggle\
[Thailand Roads (OpenStreetMap Export) from HDX](https://s3.dualstack.us-east-1.amazonaws.com/production-raw-data-api/ISO3/THA/roads/lines/hotosm_tha_roads_lines_shp.zip)\
[Thailand - Subnational Administrative Boundaries from HDX](https://data.humdata.org/dataset/cod-ab-tha?)...[Click here to download here](https://data.humdata.org/dataset/d24bdc45-eb4c-4e3d-8b16-44db02667c27/resource/d0c722ff-6939-4423-ac0d-6501830b1759/download/tha_adm_rtsd_itos_20210121_shp.zip)

# 1. Setting Up

## 1.1 Loading R Packages

I will be using the following R packages:\
-`sf` package to perform geospatial wrangling tasks \
- `spatstat` package to perform 1st- and 2nd-order spatial point patterns analysis \
- `spNetwork` package to perform network kernel density estimation (NKDE) and temporal network kernel density estimation \
- `tidyverse` package for reading csv files, dataframe processing tasks \
- `tmap` package for plotting tasks \

```{r}
pacman::p_load(tidyverse, spatstat, sf, spNetwork, tmap)
```

## 1.2 Loading Datasets

### 1.2.1 Thailand Road Accidents Data

```{r}
# Load 2019-2020 Road Accidents Data
ra_tbl <- read_csv('data/thai_road_accident_2019_2022.csv')
# Check data
glimpse(ra_tbl)
```

### 1.2.2 Thailand Openstreet Map Data

```{r}
# Load Thailand Roads from Openstreet Map
th_road <- st_read(dsn = "data/hotosm_tha_roads_lines_shp/", layer = "hotosm_tha_roads_lines_shp") 
```

```{r}
# Check data
# glimpse(th_road)
head(th_road, n=5)
```

### 1.2.3 Thailand Subnational Administrative Boundaries

Based on the description from HDX, there are a few administrative boundaries:\
- Level 0: Country\
- Level 1: Province\
- Level 2: District\
- Level 3: Sub-District, Tambon

While the dataset contains other `shp` files, the focus will be on those levels.

::: panel-tabset
# Level 0

```{r}
# Load Thailand Country from HDX
th_bound_l0 <- st_read(dsn = "data/tha_adm_rtsd_itos_20210121_shp/", layer = "tha_admbnda_adm0_rtsd_20220121")
glimpse(th_bound_l0)

# Visualize the boundaries
plot(st_geometry(th_bound_l0))
```

# Level 1

```{r}
# Load Thailand Province from HDX
th_bound_l1 <- st_read(dsn = "data/tha_adm_rtsd_itos_20210121_shp/", layer = "tha_admbnda_adm1_rtsd_20220121")
glimpse(th_bound_l1)

# Visualize the boundaries
plot(st_geometry(th_bound_l1))
```

# Level 2

```{r}
# Load Thailand Province from HDX
th_bound_l2 <- st_read(dsn = "data/tha_adm_rtsd_itos_20210121_shp/", layer = "tha_admbnda_adm2_rtsd_20220121") 
glimpse(th_bound_l2)

# Visualize the boundaries
plot(st_geometry(th_bound_l2))
```

# Level 3

```{r}
# Load Thailand Province from HDX
th_bound_l3 <- st_read(dsn = "data/tha_adm_rtsd_itos_20210121_shp/", layer = "tha_admbnda_adm3_rtsd_20220121") 
glimpse(th_bound_l3)

# Visualize the boundaries
plot(st_geometry(th_bound_l3))
```
:::

### 1.2.4 Basic Preprocessing

From a quick look of the various datasets, it is clear that preprocessing is required in order to filter the datasets to:\
1. Focus on the study area (Bangkok Metropolitan Region)\
2. Work with smaller data to better manage R session memory handling

Other geospatial preprocessing steps will also be taken accordingly. Once done, these datasets will be saved as RDS files for easy retrieval.

#### 1.2.4.1 Processing Thailand Road Accident

The Thailand road accident dataset will be processed to: - remove blanks/na from longitude/latitude (mitigate errors when converting into sf object) - filtered to Bangkok Metropolitan Region - convert tibble dataframe to sf dataframe - project to Thailand coordinate reference system for alignment and visualization

```{r}
# Transform Thailand Road Accident data
ra_tbl_flt <- ra_tbl %>%
  filter(!is.na(longitude) & longitude != "", !is.na(latitude) & latitude != "") %>%
  filter(province_en %in% c("Bangkok", "Nonthaburi", "Pathum Thani", 
                              "Samut Prakan", "Samut Sakhon", "Nakhon Pathom")) %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>%
  st_transform(crs = 32647)
```

The processed data is then exported as RDS.

```{r}
# Export to processed sub-folder as RDS
write_rds(ra_tbl_flt, 'data/processed/th_acc.rds')
```

#### 1.2.4.2 Processing Thailand Subnational Administrative Boundaries

While level 1 was sufficient to filter the boundary to the study area, level 3 was selected for the flexibility purposes.

The level 3 Thailand Subnational Administrative Boundaries will be processed based to: - filtered to Bangkok Metropolitan Region - project to Thailand coordinate reference system for alignment and visualization

```{r}
# Filter Thai boundary for only Bangkok Metropolitan Region
th_bound_l3_flt <- th_bound_l3 %>%
  filter(ADM1_EN %in% c("Bangkok", "Nonthaburi", "Pathum Thani", 
                              "Samut Prakan", "Samut Sakhon", "Nakhon Pathom"))%>%
  st_transform(crs = 32647) 

glimpse(th_bound_l3_flt)
```

The processed data is again exported as RDS.

```{r}
# Export to processed sub-folder as RDS
write_rds(th_bound_l3_flt, 'data/processed/th_bound_l3.rds')
```

#### 1.2.4.1 Processing Thailand Openstreet Map Data

Given the large openstreet map dataset (\~2.7m objects), the dataset needs to be filtered prior to performing `st_intersects`.\
This will be done by selecting the relevant highway attributes. Relevant highway attributes are defined following the [default access restrictions](https://wiki.openstreetmap.org/wiki/WikiProject_Thailand#Default_Access_Restrictions) based on the Road Traffic Act, 1979 for various different vehicle types.

```{r}
# Check types of highway in Openstreet Map data
table(ra_tbl_flt$vehicle_type)
```

```{r}
# Check types of highway in Openstreet Map data
table(th_road$highway)
```

Given that accidents involving pedestrian and bicycle etc are proportionately smaller than those involving motorcar and motorcycle, the openstreet map data will be filtered to include relevant highway attribute for the latter vehicle types.

```{r}
# Filter Thai Openstreet Map data by highway types 
th_road_flt <- th_road %>%
  filter(highway %in% c('motorway', 'trunk', 'primary', 'secondary', 'tertiary', 'unclassified', 'residential',  # Roads
                        'motorway_link', 'trunk_link', 'primary_link', 'secondary_link', 'tertiary_link',  # Link Roads
                        'living_street', 'road', 'path'
                        ) 
         ) %>%
  st_set_crs(., 4326) %>%
  st_transform(crs = 32647) 
glimpse(th_road_flt)
```

`st_intersects` is then used to return openstreet map objects that are within the study area.

```{r}
# # Use st_union to get overall study area boundary
th_bound_union <- th_bound_l3_flt %>%
  st_union()

# Use st_intersects to get roads within the study area
th_roads_intersects <- st_intersects(th_road_flt, th_bound_union)

# Get index mask of roads objects that intersects with study area 
roads_logical <- lengths(th_roads_intersects) > 0
# Filter openstreet map with the index mask
th_roads_bmr <- th_road_flt[roads_logical, ]


glimpse(th_roads_bmr)
```

The processed openstreet map dataset is then exported in a similar fashion

```{r}
# Export to processed sub-folder as RDS
write_rds(th_roads_bmr, 'data/processed/th_osm.rds')
```

# 2. Exploratory Data Analysis

## 2.1 Setting Up Environtment from Processed Datasets

First, we clear the R console, then load in the processed datasets. This is a suitable starting point to bypass the long loading/processing time of the various large datasets.

```{r}
# Clear R console
rm(list = ls(all.names = TRUE))
```

::: panel-tabset
# Accidents

```{r}
# Load data
ra_sf <- read_rds('data/processed/th_acc.rds')

# Check data
glimpse(ra_sf)

# Check crs
st_crs(ra_sf)
```

# Administrative Boundary

```{r}
# Load data
th_bound_sf <- read_rds('data/processed/th_bound_l3.rds')

# Check data
glimpse(th_bound_sf)

# Check crs
st_crs(th_bound_sf)
```

# Openstreet Map

```{r}
# Load data
th_osm_sf <- read_rds('data/processed/th_osm.rds')

# Check data
glimpse(th_osm_sf)

# Check crs
st_crs(th_osm_sf)
```
:::

## 2.2 Microsoft Power Bi Visualization

::: {style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%;"}
<iframe title="Geospatial TakeHome Ex01" src="https://app.powerbi.com/view?r=eyJrIjoiZmMxMTNjMzEtYzhmMy00NTgwLTlkMjctODE1ZTA5YjNmN2E3IiwidCI6ImRmNGU4MzA3LWRjNjQtNDcyYS1iNGI1LWE2ZGQ2YmExMTU2NiIsImMiOjEwfQ%3D%3D" frameborder="0" allowFullScreen="true" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">

</iframe>
:::

# 3. Spatial Point Pattern Analysis

Before any meaningful analysis between any factors and accidents can be made, we need to know if the accidents events occur following a pattern or at random via spatial point patterns analysis. This analysis can also help us to understand if the events vary due to changes in underlying property (e.g. road types) or if they vary due to interaction effects betwee This will be established through first-order and second-order spatial point pattern analysis.

## 3.1 First-Order Spatial Point Pattern Analysis

Under this section, Kernel Density Estimation and Nearest Neighbour Distance will be explored as density-based and distance-based techniques respectively. This is bearing in mind their respective strengths.

### 3.1.1 Density-Based: Kernel Density Estimation

Additional preparation is required to perform the analysis. These include:\
- Preparing the accident data in ppp object for `spatstat`\
- Checking the accident data for duplicates\
- Preparing the owin object\


```{r}
# Set seed to ensure reproducibility of all subsequent analysis
set.seed(42)

# Convert accidents data to ppp format
ra_ppp <- as.ppp(ra_sf)

# Check accidents events for duplicates
any(duplicated(ra_ppp))
```

```{r}
# Create owin object
th_bound_owin <- as.owin(th_bound_sf)

# Combine events object and owin object
ra_th_bound_ppp <-  ra_ppp[th_bound_owin]

# Rescale ppp from meter to kilometer
ra_th_bound_ppp_km <- rescale.ppp(ra_th_bound_ppp, 1000, "km")
```

### 3.1.1.1 Adaptive Kernel Density Estimation

Based on the context of road accidents, adaptive kernel density estimation is more appropriate than fixed kernel density estimation as the accidents are more heterogeneous as observed from the EDA.

```{r}
# Perform adative bandwith KDE
kde_ra_adp <- adaptive.density(ra_th_bound_ppp_km, method="kernel")
plot(kde_ra_adp, 
     main = paste0("Adaptive KDE"),
     cex.axis = 0.8)
```

The intensities can be observed as small strips, which are notable roads (i.e. Kanchanaphisek Road) where sizable proportions of the accidents happen. This

Lets see if there are any differences when looking at individual provinces.

::: panel-tabset
# Bangkok

```{r}
# Create Bangkok ppp object
ra_bk_ppp <- ra_sf %>%
  filter(province_en == 'Bangkok') %>%
  as.ppp()

# Create Bangkok owin object
bk_owin <- th_bound_sf %>%
  filter(ADM1_EN == 'Bangkok') %>%
  as.owin()

# Combine events object and owin object
ra_bk_bound <-  ra_bk_ppp[bk_owin]

# Rescale ppp from meter to kilometer
ra_bk_bound_km <- rescale.ppp(ra_bk_bound, 1000, "km")

# Perform adaptive bandwidth KDE
kde_ra_adp_bk <- adaptive.density(ra_bk_bound_km, method="kernel")
plot(kde_ra_adp_bk, 
     main = paste0("Adaptive KDE: Bangkok"),
     cex.axis = 0.8)

```

# Nonthaburi

```{r}
# Create Nonthaburi ppp object
ra_ntb_ppp <- ra_sf %>%
  filter(province_en == 'Nonthaburi') %>%
  as.ppp()

# Create Nonthaburi owin object
ntb_owin <- th_bound_sf %>%
  filter(ADM1_EN == 'Nonthaburi') %>%
  as.owin()

# Combine events object and owin object
ra_ntb_bound <-  ra_ntb_ppp[ntb_owin]

# Rescale ppp from meter to kilometer
ra_ntb_bound_km <- rescale.ppp(ra_ntb_bound, 1000, "km")

# Perform adaptive bandwidth KDE
kde_ra_adp_ntb <- adaptive.density(ra_ntb_bound_km, method="kernel")
plot(kde_ra_adp_ntb, 
     main = paste0("Adaptive KDE: Nonthaburi"),
     cex.axis = 0.8)

```

# Pathum Thani

```{r}
# Create Pathum Thani ppp object
ra_pt_ppp <- ra_sf %>%
  filter(province_en == 'Pathum Thani') %>%
  as.ppp()

# Create Pathum Thani owin object
pt_owin <- th_bound_sf %>%
  filter(ADM1_EN == 'Pathum Thani') %>%
  as.owin()

# Combine events object and owin object
ra_pt_bound <-  ra_pt_ppp[pt_owin]

# Rescale ppp from meter to kilometer
ra_pt_bound_km <- rescale.ppp(ra_pt_bound, 1000, "km")

# Perform adaptive bandwidth KDE
kde_ra_adp_pt <- adaptive.density(ra_pt_bound_km, method="kernel")
plot(kde_ra_adp_pt, 
     main = paste0("Adaptive KDE: Pathum Thani"),
     cex.axis = 0.8)

```

# Samut Prakan

```{r}
# Create Samut Prakan ppp object
ra_sp_ppp <- ra_sf %>%
  filter(province_en == 'Samut Prakan') %>%
  as.ppp()

# Create Samut Prakan owin object
sp_owin <- th_bound_sf %>%
  filter(ADM1_EN == 'Samut Prakan') %>%
  as.owin()

# Combine events object and owin object
ra_sp_bound <-  ra_sp_ppp[sp_owin]

# Rescale ppp from meter to kilometer
ra_sp_bound_km <- rescale.ppp(ra_sp_bound, 1000, "km")

# Perform adaptive bandwidth KDE
kde_ra_adp_sp <- adaptive.density(ra_sp_bound_km, method="kernel")
plot(kde_ra_adp_sp, 
     main = paste0("Adaptive KDE: Samut Prakan"),
     cex.axis = 0.8)

```

# Samut Sakhon

```{r}
# Create Samut Sakhon ppp object
ra_ss_ppp <- ra_sf %>%
  filter(province_en == 'Samut Sakhon') %>%
  as.ppp()

# Create Samut Sakhon owin object
ss_owin <- th_bound_sf %>%
  filter(ADM1_EN == 'Samut Sakhon') %>%
  as.owin()

# Combine events object and owin object
ra_ss_bound <-  ra_ss_ppp[ss_owin]

# Rescale ppp from meter to kilometer
ra_ss_bound_km <- rescale.ppp(ra_ss_bound, 1000, "km")

# Perform adaptive bandwidth KDE
kde_ra_adp_ss <- adaptive.density(ra_ss_bound_km, method="kernel")
plot(kde_ra_adp_ss, 
     main = paste0("Adaptive KDE: Samut Sakhon"),
     cex.axis = 0.8)

```

# Nakhon Pathom

```{r}
# Create Nakhon Pathom ppp object
ra_np_ppp <- ra_sf %>%
  filter(province_en == 'Nakhon Pathom') %>%
  as.ppp()

# Create Nakhon Pathom owin object
np_owin <- th_bound_sf %>%
  filter(ADM1_EN == 'Nakhon Pathom') %>%
  as.owin()

# Combine events object and owin object
ra_np_bound <-  ra_np_ppp[np_owin]

# Rescale ppp from meter to kilometer
ra_np_bound_km <- rescale.ppp(ra_np_bound, 1000, "km")

# Perform adaptive bandwidth KDE
kde_ra_adp_np <- adaptive.density(ra_np_bound_km, method="kernel")
plot(kde_ra_adp_np, 
     main = paste0("Adaptive KDE: Nakhon Pathom"),
     cex.axis = 0.8)

```
:::

Conclusion: 

### 3.1.1.2 Fixed Kernel Density Estimation

While fixed KDE is less applicable, it will be interesting to compare the output with adaptive KDE.

`bw.ppl()` will be used as the automatic kernel method to determine the sigma as the pattern seems to consist mostly of tight clusters around major roads.\
Gaussian will be the smoothing kernel of choice, as it is widely used and there are no negative events in the current context.

```{r}
# Get fixed bandwidth 
fixed_bw <- bw.ppl(ra_th_bound_ppp_km)

# Perform fixed kernel density estimation
plot(density(ra_th_bound_ppp_km, sigma=fixed_bw, edge=TRUE, kernel="gaussian"), 
     main = paste0("Fixed KDE: Bandwidth=", round(fixed_bw, 4)),
     cex.axis = 0.8)
```

Interestingly,

### 3.1.2 Distance-Based: Nearest Neighbour Index

`clarkevans.test()` of spatstat will be used to perform the Clark-Evans test of aggregation.\
H0: Distribution of road accidents are randomly distributed 
H1: Distribution of road accidents are *not* randomly distributed

```{r}
# Perform Clark-Evans on study area 
clarkevans.test(ra_th_bound_ppp,
                correction="none",
                clipregion="th_bound_owin",
                alternative=c("clustered"),
                nsim=99 # 100 simulation runs
                )
```

Conclusion: 

Now lets do the same for each province

::: panel-tabset
# Bangkok

```{r}
# Perform Clark-Evans on Bangkok
clarkevans.test(ra_bk_bound,
                correction="none",
                clipregion="bk_owin",
                alternative=c("clustered"),
                nsim=99 # 100 simulation runs
                )
```

# Nonthaburi

```{r}
# Perform Clark-Evans on Nonthaburi
clarkevans.test(ra_ntb_bound,
                correction="none",
                clipregion="ntb_owin",
                alternative=c("clustered"),
                nsim=99 # 100 simulation runs
                )
```

# Pathum Thani

```{r}
# Perform Clark-Evans on Pathum Thani
clarkevans.test(ra_pt_bound,
                correction="none",
                clipregion="pt_owin",
                alternative=c("clustered"),
                nsim=99 # 100 simulation runs
                )
```

# Samut Prakan

```{r}
# Perform Clark-Evans on Samut Prakan
clarkevans.test(ra_sp_bound,
                correction="none",
                clipregion="sp_owin",
                alternative=c("clustered"),
                nsim=99 # 100 simulation runs
                )
```

# Samut Sakhon

```{r}
# Perform Clark-Evans on Samut Sakhon
clarkevans.test(ra_ss_bound,
                correction="none",
                clipregion="ss_owin",
                alternative=c("clustered"),
                nsim=99 # 100 simulation runs
                )
```

# Nakhon Pathom

```{r}
# Perform Clark-Evans on Nakhon Pathom
clarkevans.test(ra_np_bound,
                correction="none",
                clipregion="np_owin",
                alternative=c("clustered"),
                nsim=99 # 100 simulation runs
                )
```
:::

Conclusion: 

## 3.2 Second-Order Spatial Point Pattern Analysis

### 3.2.1



# 4 Network Spatial Point Pattern Analysis

# 5 Temporal Network Spatial Point Patterns Analysis

# 6. Conclusion
