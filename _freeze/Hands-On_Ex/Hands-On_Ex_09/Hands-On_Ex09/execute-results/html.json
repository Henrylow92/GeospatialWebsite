{
  "hash": "457103c89918df8a267ed0af3bb57c85",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-On Exercise 09\"\nauthor: \"Henry Low\"\ndate: \"Oct 18 2024\"\ndate-modified: \"last-modified\"\nexecute:\n  evalu: true\n  echo: true\n  message: false\n  freeze: true\nformat: html\neditor: visual\n---\n\n\n\n# Data Sources\n\n*(saved under 'data' folder)*\n\nFour data sets will be used in this hands-on exercise, they are:\n\n-   `MP14_SUBZONE_NO_SEA_PL`: URA Master Plan 2014 subzone boundary GIS data. This data set is downloaded from data.gov.sg.\n-   `hexagons`: A 250m radius hexagons GIS data. This data set was created by using [*st_make_grid()*](https://r-spatial.github.io/sf/reference/st_make_grid.html) of sf package. It is in ESRI shapefile format.\n-   `ELDERCARE`: GIS data showing location of eldercare service. [This data](https://data.gov.sg/dataset/eldercare-services) is downloaded from data.gov.sg. There are two versions. One in ESRI shapefile format. The other one in Google kml file format. For the purpose of this hands-on exercise, ESRI shapefile format is provided.\n-   `OD_Matrix`: a distance matrix in csv format. There are six fields in the data file. They are:\n    -   `origin_id`: the unique id values of the origin (i.e. `fid` of hexagon data set.),\n    -   `destination_id`: the unique id values of the destination (i.e. `fid` of `ELDERCARE` data set.),\n    -   `entry_cost`: the perpendicular distance between the origins and the nearest road),\n    -   `network_cost`: the actual network distance from the origin and destination,\n    -   `exit_cost`: the perpendicular distance between the destination and the nearest road), and\n    -   `total_cost`: the summation of `entry_cost`, `network_cost` and `exit_cost`.\n\n::: {.callout-note}\nAll the values of the cost related fields are in metres.\n:::\n\n# Chapter 17: Modelling Geographical Accessibility\n\n## 17.1 Setting Up\n\nThe goal of this exercise is to:\n\n-   to import GIS polygon data into R and save them as simple feature data frame by using appropriate functions of sf package of R;\n-   to import aspatial data into R and save them as simple feature data frame by using appropriate functions of sf package of R;\n-   to computer accessibility measure by using Hansen’s potential model and Spatial Accessibility Measure (SAM); and\n-   to visualise the accessibility measures by using tmap and ggplot2 packages.\n\n### 17.1.1 Loading the R packages\n\n\\-`sf` package to perform geospatial wrangling tasks \\\n-`SpatialAcc` package to model geographical accessibility tasks \\\n- `ggstatsplot` package for statistical analysis \\\n- `tmap` and `ggplot2` package for plotting tasks \\\n-`tidyverse` and `reshape2` package for reading csv files, dataframe processing tasks \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tmap, SpatialAcc, sf, \n               ggstatsplot, reshape2,\n               tidyverse)\n```\n:::\n\n\n\n### 17.1.2 Importing Geospatial Data\n\n`st_read()` from `sf` package will be used to load the geospatial datasets. Projection will also be done with `st_transform()` to 3414.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Import mpsz data\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_NO_SEA_PL\") %>%\n  st_transform(3414)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_NO_SEA_PL' from data source \n  `C:\\Users\\Henry\\Desktop\\SMU Masters\\2024-2025 T1\\Geospatial Analytics & Applications\\Project\\GeospatialWebsite\\Hands-On_Ex\\Hands-On_Ex_09\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n\n```{.r .cell-code}\n# Import hexagon data\nhexagons <- st_read(dsn = \"data/geospatial\", layer = \"hexagons\") %>%\n  st_transform(3414)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `hexagons' from data source \n  `C:\\Users\\Henry\\Desktop\\SMU Masters\\2024-2025 T1\\Geospatial Analytics & Applications\\Project\\GeospatialWebsite\\Hands-On_Ex\\Hands-On_Ex_09\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3125 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 21506.33 xmax: 50010.26 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\n```\n\n\n:::\n\n```{.r .cell-code}\n# Import eldercare data\neldercare <- st_read(dsn = \"data/geospatial\", layer = \"ELDERCARE\") %>%\n  st_transform(3414)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `ELDERCARE' from data source \n  `C:\\Users\\Henry\\Desktop\\SMU Masters\\2024-2025 T1\\Geospatial Analytics & Applications\\Project\\GeospatialWebsite\\Hands-On_Ex\\Hands-On_Ex_09\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 120 features and 19 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 14481.92 ymin: 28218.43 xmax: 41665.14 ymax: 46804.9\nProjected CRS: SVY21 / Singapore TM\n```\n\n\n:::\n:::\n\n\n\n`st_crs()` can be used to ensure that the project is done successfully.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check projection\nst_crs(mpsz)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n\n\n:::\n:::\n\n\n\n### 17.1.3 Geospatial Data Wrangling\n\nSince there are redundant fields in the loaded eldercare and hexagon datasets, I will need to filter them to select only the fields i need. New fields called demand and capacity will be created for hexagons and eldercare sf dataframe respectively with `mutate()` from `dplyr` package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Process eldercare dataframe\neldercare <- eldercare %>%\n  select(fid, ADDRESSPOS) %>%\n  mutate(capacity = 100)\n\n# Process hexagons dataframe\nhexagons <- hexagons %>%\n  select(fid) %>%\n  mutate(demand = 100)\n```\n:::\n\n\n\n::: {.callout-note}\nWhile a constant value of 100 is used, in actual practice actual demand of the hexagon and eldercare centre capacity should be used instead.\n:::\n\n### 17.1.4 Importing Aspatial Data\n\nUsing `read_csv()` from `readr` package, I will load in the `OD_Matrix.csv` dataset.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load OD_matrix data\nODMatrix <- read_csv(\"data/aspatial/OD_Matrix.csv\", skip = 0)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 375000 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (6): origin_id, destination_id, entry_cost, network_cost, exit_cost, tot...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check data\nODMatrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 375,000 × 6\n   origin_id destination_id entry_cost network_cost exit_cost total_cost\n       <dbl>          <dbl>      <dbl>        <dbl>     <dbl>      <dbl>\n 1         1              1       668.       19847.      47.6     20562.\n 2         1              2       668.       45027.      31.9     45727.\n 3         1              3       668.       17644.     173.      18486.\n 4         1              4       668.       36010.      92.2     36770.\n 5         1              5       668.       31068.      64.6     31801.\n 6         1              6       668.       31195.     117.      31980.\n 7         1              8       668.       32475.      55.1     33198.\n 8         1              9       668.       22267.      28.4     22963.\n 9         1             10       668.       45220.      55.1     45943.\n10         1             11       668.       34898.      27.5     35593.\n# ℹ 374,990 more rows\n```\n\n\n:::\n:::\n\n\n\nFrom this, we can see that the distance matrix is in a long format, row-wise with \"origin_id\" and \"destination_id\". Most modelling packages in R expects a wide format with row representing \"origin\" (from), and columns representing \"destination\" (to). Therefore, I will need to use `pivot_wider()` from `tidyr` package to transform the OD matrix from long to wide format.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pivot OD matrix\ndistmat <- ODMatrix %>%\n  select(origin_id, destination_id, total_cost) %>%\n  # spread(destination_id, total_cost) %>%\n  pivot_wider(names_from = destination_id, values_from = total_cost) %>% # Use pivot_wider() instead\n  select(c(-c('origin_id')))\n```\n:::\n\n\n\nSince the distance is measured in metre (due to SVY21 projected coordinate system), I will create another matrix which is in kilometre.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Km based OD matrix\ndistmat_km <- as.matrix(distmat/1000)\n```\n:::\n\n\n\n## 17.2 Modelling and Visualizing Accessibility (Hansen Method)\n\n### 17.2.1 Compute Hansen's Accessibility\n\nNow, I will use `ac()` from `SpatialAcc` package to compute Hansen's accessibility. The following table provides an overview of the arguments of the function.\n\n| Argument | Description                                                                                                                                                                      |\n|-------------|-----------------------------------------------------------|\n| p        | Vector that quantifies the demand for services in each location, usually the population at risk                                                                                  |\n| n        | Vector that quantifies the supply of services in each location, usually a characteristic of the service.                                                                         |\n| D        | Matrix of a quantity separating the demand from the supply. This is usually a distance matrix, preferably using a road network distance or travel time through the road network. |\n| d0       | Threshold distance or time that defines the catchment area (spatial kernel)                                                                                                      |\n| power    | (default = 2) Power of the separation variable, usually 2 from the theory of gravity model in geography.                                                                         |\n| family   | (default = \"SAM\") Character value to define the accessibility measure function (\"SAM\", \"2SFCA\", \"KD2SFCA\", \"Hansen\")                                                             |\n\nThe output will be saved as a dataframe.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute Hansen's accessibility\nacc_Hansen <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            #d0 = 50,\n                            power = 2, \n                            family = \"Hansen\"))\n\n# Check output\nhead(acc_Hansen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ac.hexagons.demand..eldercare.capacity..distmat_km..power...2..\n1                                                    1.648313e-14\n2                                                    1.096143e-16\n3                                                    3.865857e-17\n4                                                    1.482856e-17\n5                                                    1.051348e-17\n6                                                    5.076391e-18\n```\n\n\n:::\n:::\n\n\n\nGiven the long field name, I will rename it to \"accHansen\". Next, i will convert it into tibble format using `tbl_df()`. Finally, `bind_cols()` from `dplyr` will be used to join the acc_Hansen tibble dataframe with the hexagons sf dataframe.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Rename column name\ncolnames(acc_Hansen) <- \"accHansen\"\n\n# Convert to tibble\nacc_Hansen <- as.tibble(acc_Hansen)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `as.tibble()` was deprecated in tibble 2.0.0.\nℹ Please use `as_tibble()` instead.\nℹ The signature and semantics have changed, see `?as_tibble`.\n```\n\n\n:::\n\n```{.r .cell-code}\n# Join to hexagon sf dataframe\nhexagon_Hansen <- bind_cols(hexagons, acc_Hansen)\n\n# Check result\nhexagon_Hansen\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 3125 features and 3 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 21506.33 xmax: 50010.26 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\nFirst 10 features:\n   fid demand    accHansen                       geometry\n1    1    100 1.648313e-14 POLYGON ((2667.538 27506.33...\n2    2    100 1.096143e-16 POLYGON ((2667.538 25006.33...\n3    3    100 3.865857e-17 POLYGON ((2667.538 24506.33...\n4    4    100 1.482856e-17 POLYGON ((2667.538 24006.33...\n5    5    100 1.051348e-17 POLYGON ((2667.538 23506.33...\n6    6    100 5.076391e-18 POLYGON ((2667.538 23006.33...\n7    7    100 1.769616e-13 POLYGON ((3100.551 28756.33...\n8    8    100 9.979647e-14 POLYGON ((3100.551 28256.33...\n9    9    100 5.671831e-14 POLYGON ((3100.551 27756.33...\n10  10    100 2.621063e-14 POLYGON ((3100.551 27256.33...\n```\n\n\n:::\n:::\n\n\n\n### 17.2.2 Visualize Hansen's Accessibility\n\nBefore processing to visualize the Hansen's accessibility, I will need to extract the extent of `hexagons` sf dataframe with `st_bbox()` from `sf` package. `tmap` will then be used to visualize the hexagon with the extracted bounding box\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract hexagon extent\nmapex <- st_bbox(hexagons)\n\n# Set tmap mode to plot\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\n# Visualize hansen accessibility\ntm_shape(hexagon_Hansen,\n         bbox = mapex) + \n  tm_fill(col = \"accHansen\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: Hansen method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex09_files/figure-html/unnamed-chunk-10-1.png){width=1152}\n:::\n:::\n\n\n\n### 17.2.3 Statistical Graphic Visualization\n\nNow, I am going to compare the distribution of Hansen's accessibility values by URA planning region. Before doing so, I need to add the planning region field into hexagon_Hansen sf dataframe.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add planning region field\nhexagon_Hansen <- st_join(hexagon_Hansen, mpsz, \n                          join = st_intersects)\n```\n:::\n\n\n\nNow, i can use `gglot()` to visualize the distribution with boxplots.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualize hansen by planning region\nggplot(data=hexagon_Hansen, \n       aes(y = log(accHansen), \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo summary function supplied, defaulting to `mean_se()`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-On_Ex09_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n## 17.3 Modelling and Visualizing Accessibility (KD2SFCA Method)\n\n### 17.3.1 Compute KD2SFCA Accessibility\n\nGiven the steps to visualize accessibility are largely similar, I will do the same for the KD2SFCA method similar with Hansen's method.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute KD2SFCA accessibility\nacc_KD2SFCA <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            d0 = 50,\n                            power = 2, \n                            family = \"KD2SFCA\"))\n\n# Rename column name\ncolnames(acc_KD2SFCA) <- \"accKD2SFCA\"\n\n# Convert to tibble\nacc_KD2SFCA <- as.tibble(acc_KD2SFCA)\n\n# Join hexagon sf dataframe\nhexagon_KD2SFCA <- bind_cols(hexagons, acc_KD2SFCA)\n\n# Check result\nhexagon_KD2SFCA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 3125 features and 3 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 21506.33 xmax: 50010.26 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\nFirst 10 features:\n   fid demand    accKD2SFCA                       geometry\n1    1    100 1.745751e-149 POLYGON ((2667.538 27506.33...\n2    2    100 1.849596e-192 POLYGON ((2667.538 25006.33...\n3    3    100 4.442757e-202 POLYGON ((2667.538 24506.33...\n4    4    100 3.938161e-211 POLYGON ((2667.538 24006.33...\n5    5    100 1.985397e-214 POLYGON ((2667.538 23506.33...\n6    6    100 1.706598e-221 POLYGON ((2667.538 23006.33...\n7    7    100 4.852269e-131 POLYGON ((3100.551 28756.33...\n8    8    100 2.223365e-135 POLYGON ((3100.551 28256.33...\n9    9    100 9.933137e-140 POLYGON ((3100.551 27756.33...\n10  10    100 8.756260e-146 POLYGON ((3100.551 27256.33...\n```\n\n\n:::\n:::\n\n\n\n### 17.3.2 Visualize KD2SFCA Accessibility\n\nLikewise, similar code will be used to visualize KD2SFCA accessibility. Since mapex is already created, I can just reuse it.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set tmap mode to plot\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\n# Visualize KD2SFCA accessibility\ntm_shape(hexagon_KD2SFCA,\n         bbox = mapex) + \n  tm_fill(col = \"accKD2SFCA\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: KD2SFCA method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex09_files/figure-html/unnamed-chunk-14-1.png){width=1152}\n:::\n:::\n\n\n\n### 17.3.3 Statistical Graphic Visualization\n\nTo compare the distribution of KD2SFCA accessibility by URA planning region, I will do the same as before - joining the planning region field before plotting the distribution with a boxplot\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Join planning region field\nhexagon_KD2SFCA <- st_join(hexagon_KD2SFCA, mpsz, \n                          join = st_intersects)\n\n# Visualize KD2SFCA accessibility by planning region\nggplot(data=hexagon_KD2SFCA, \n       aes(y = accKD2SFCA, \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo summary function supplied, defaulting to `mean_se()`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-On_Ex09_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n## 17.4 Modelling and Visualizing Accessibility (Spatial Accessibility Measure - SAM Method)\n\n### 17.4.1 Compute SAM Accessibility\n\nTo use the spatial accessibility measure method, the code will be largely similar as other methods, with the exception of the family argument input. (SAM being used instead). The subsequent steps follow closely as the other methods.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute sam accessibility\nacc_SAM <- data.frame(ac(hexagons$demand,\n                         eldercare$capacity,\n                         distmat_km, \n                         d0 = 50,\n                         power = 2, \n                         family = \"SAM\"))\n\n# Rename column name\ncolnames(acc_SAM) <- \"accSAM\"\n\n# Convert to tibble\nacc_SAM <- as.tibble(acc_SAM)\n\n# Join to hexagon sf dataframe\nhexagon_SAM <- bind_cols(hexagons, acc_SAM)\n\n# Check result\nhexagon_SAM\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 3125 features and 3 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 21506.33 xmax: 50010.26 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\nFirst 10 features:\n   fid demand     accSAM                       geometry\n1    1    100 0.11941792 POLYGON ((2667.538 27506.33...\n2    2    100 0.10101549 POLYGON ((2667.538 25006.33...\n3    3    100 0.09775876 POLYGON ((2667.538 24506.33...\n4    4    100 0.09490965 POLYGON ((2667.538 24006.33...\n5    5    100 0.09391923 POLYGON ((2667.538 23506.33...\n6    6    100 0.09187587 POLYGON ((2667.538 23006.33...\n7    7    100 0.13009759 POLYGON ((3100.551 28756.33...\n8    8    100 0.12738225 POLYGON ((3100.551 28256.33...\n9    9    100 0.12479277 POLYGON ((3100.551 27756.33...\n10  10    100 0.12139059 POLYGON ((3100.551 27256.33...\n```\n\n\n:::\n:::\n\n\n\n### 17.4.2 Visualize SAM Accessibility\n\nTo visualize SAM accessibility, I will reuse the mapex and code used to visualize other methods, updating the `tm_shape()` input with the corresponding hexagon sf dataframe containing SAM accessibility.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set tmap mode to plot\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\n# Visualize SAM accessibility\ntm_shape(hexagon_SAM,\n         bbox = mapex) + \n  tm_fill(col = \"accSAM\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: SAM method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 3),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex09_files/figure-html/unnamed-chunk-17-1.png){width=1152}\n:::\n:::\n\n\n\n### 17.4.3 Statistical Graphic Visualization\n\nTo compare the distribution of SAM accessibility by URA planning region, the same can be done - join the planning region field then use\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Join planning region field\nhexagon_SAM <- st_join(hexagon_SAM, mpsz, \n                       join = st_intersects)\n\n# Visualize sam accessibility by planning region\nggplot(data=hexagon_SAM, \n       aes(y = accSAM, \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo summary function supplied, defaulting to `mean_se()`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-On_Ex09_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Hands-On_Ex09_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}